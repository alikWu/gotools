package internal2

import (
	"bytes"
	"fmt"
	"os"
	"strings"
)

type Generator struct {
	pkg *Package
	buf bytes.Buffer
}

func (g *Generator) ParsePackage(pkgPath string) {
	g.pkg = NewPackage(pkgPath)
}

func (g *Generator) InjectAllTypes() {
	pkgTypesMap := g.pkg.GetPublicTypeNames()

	targetPkg := os.Getenv("GOPACKAGE")

	// Print the header and package clause.
	g.print("// Code generated by injector %s; DO NOT EDIT.\n\n", strings.Join(os.Args[1:], " "))
	g.print("package %s\n\n", targetPkg)

	//import
	g.print("import (\n")
	for pkg, _ := range pkgTypesMap {
		g.print("\t\"%s\"\n", pkg)
	}
	g.print(")\n\n")

	g.print("var beanFactory = make(map[string]interface{})\n\n")

	g.print("func Init() {\n")
	for pkg, types := range pkgTypesMap {
		for _, tn := range types {
			g.print(fmt.Sprintf("\tbeanFactory[\"%s\"] = new(%s.%s)\n", pkg, pkg[strings.LastIndex(pkg, "/")+1:], tn))
		}
		g.print("\n")
	}
	g.print("}\n")

	g.print("func GetObject(structName string) interface{} {\n")
	g.print("\treturn beanFactory[structName]\n")
	g.print("}")
}

func (g *Generator) print(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) WriteFile(fileName string) error {
	file, err := os.Create(fileName)
	if err != nil {
		return err
	}

	_, err = file.Write(g.buf.Bytes())
	return err
}
